<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Folder Drill System</title>
  <style>
    body { font-family: sans-serif; padding: 10px; }
    h1, h2 { text-align: center; }
    section { border: 1px solid #ccc; padding: 10px; margin: 10px; }
    button, input { margin: 5px; }
    video { display: block; margin: 10px auto; }
  </style>
</head>
<body>
  <h1>Folder Drill System</h1>
  
  <!-- Drill Section (always visible at the top) -->
  <section id="drillSection">
    <h2>Drill</h2>
    <div id="drill-card-section">
      <h3 id="currentWord"></h3>
      <button id="showTextBtn">Show Example</button>
      <p id="currentExample" style="display:none;"></p>
      <button id="playFragmentBtn">Play Video Fragment</button>
      <div id="ratingSection">
        <button class="ratingBtn" data-quality="0">Bad</button>
        <button class="ratingBtn" data-quality="3">OK</button>
        <button class="ratingBtn" data-quality="5">Good</button>
      </div>
      <button id="ignoreWordBtn">Ignore Word</button>
      <video id="drillVideo" controls width="600"></video>
    </div>
  </section>
  
  <!-- Folder Management Section -->
  <section id="folderManagement">
    <h2>Load Folder</h2>
    <!-- This input lets you select a folder (supported in Chrome and some browsers) -->
    <input type="file" id="folderInput" webkitdirectory directory>
  </section>
  
  <!-- New Content Section: Add New Video + SRT -->
  <section id="newContentSection">
    <h2>Add New Content (Video + SRT)</h2>
    <div>
      <label for="newVideo">Video File:</label>
      <input type="file" id="newVideo" accept="video/*">
      <label for="newSRT">SRT File:</label>
      <input type="file" id="newSRT" accept=".srt">
      <button id="addNewContentBtn">Add New Content</button>
    </div>
  </section>
  
  <script>
    /**************************************************
     * Global Variables
     **************************************************/
    // wordData: key = word; value: { examples: [{ text, video, start, end }], repetition, interval, ease, nextReview, ignored }
    let wordData = {};   
    let words = [];      // Array of word keys
    let videoFolderFiles = []; // Array to hold video File objects from folder load.
    let videoMapping = {};     // Mapping: video file name -> object URL
    let currentExampleObj = null; // Chosen example for the current card
    let currentWord = "";
    
    /**************************************************
     * Utility: SRT Parsing
     **************************************************/
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      let results = [];
      for (let block of blocks) {
        const lines = block.split(/\r?\n/).map(l => l.trim()).filter(l => l);
        if (lines.length < 2) continue;
        let timeLine = '';
        let textLines = [];
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          timeLine = lines[0];
          textLines = lines.slice(1);
        }
        if (!timeLine.includes('-->')) continue;
        const [startStr, endStr] = timeLine.split('-->').map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);
        const text = textLines.join(' ');
        results.push({ start: startSec, end: endSec, text: text });
      }
      return results;
    }
    
    function srtTimeToSeconds(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length < 3) return 0;
      const [hh, mm, ssMs] = parts;
      const [ss, ms] = ssMs.split(',');
      return (parseInt(hh) * 3600) + (parseInt(mm) * 60) + parseInt(ss) + (parseInt(ms) / 1000);
    }
    
    /**************************************************
     * Folder Management: Load Folder Instead of Archive
     **************************************************/
    document.getElementById("folderInput").addEventListener("change", (e) => {
      const files = e.target.files;
      if (!files.length) return;
      // Loop through all selected files.
      Array.from(files).forEach(file => {
        // If the file is named "words.json", load it as our JSON data.
        if (file.name === "words.json") {
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              wordData = JSON.parse(ev.target.result);
              words = Object.keys(wordData);
              console.log("Loaded JSON data from folder.");
              // Start drill if not already started.
              if (!currentWord) {
                currentWord = getNextCard();
                if (currentWord) showCurrentCard();
              }
            } catch (err) {
              alert("Error parsing words.json: " + err);
            }
          };
          reader.readAsText(file);
        }
        // Otherwise, if the file is a video file (check common extensions), add it.
        else if (/\.(mp4|webm|ogg)$/i.test(file.name)) {
          // Store the object URL for the video.
          videoMapping[file.name] = URL.createObjectURL(file);
          videoFolderFiles.push(file);
          console.log("Loaded video:", file.name);
        }
      });
      alert("Folder loaded.");
    });
    
    /**************************************************
     * 1) Add New Content (Video + SRT)
     **************************************************/
    document.getElementById("addNewContentBtn").addEventListener("click", () => {
      const videoInput = document.getElementById("newVideo");
      const srtInput = document.getElementById("newSRT");
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      
      // Add video file to mapping if not already loaded.
      if (!videoMapping[videoFile.name]) {
        videoMapping[videoFile.name] = URL.createObjectURL(videoFile);
        videoFolderFiles.push(videoFile);
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const srtContent = e.target.result;
        const srtBlocks = parseSRT(srtContent);
        srtBlocks.forEach(block => {
          const wordsInBlock = block.text.toLowerCase().match(/[a-zA-Z]+/g);
          if (wordsInBlock) {
            wordsInBlock.forEach(word => {
              if (!wordData[word]) {
                wordData[word] = {
                  examples: [{
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  }],
                  repetition: 0,
                  interval: 0,
                  ease: 2.5,
                  nextReview: Date.now(),
                  ignored: false
                };
              } else {
                const exists = wordData[word].examples.some(ex => ex.text === block.text && ex.video === videoFile.name);
                if (!exists) {
                  wordData[word].examples.push({
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  });
                }
              }
            });
          }
        });
        words = Object.keys(wordData);
        alert("New content added from SRT.");
        if (!currentWord) {
          currentWord = getNextCard();
          if (currentWord) showCurrentCard();
        }
      };
      reader.readAsText(srtFile);
    });
    
    /**************************************************
     * 2) (No Export Folder Functionality Provided)
     * You can implement saving the JSON to a file if needed.
     **************************************************/
    
    /**************************************************
     * 3) Drill Section: Scheduling & UI
     **************************************************/
    function ensureCardProperties(word) {
      const card = wordData[word];
      if (card.repetition === undefined) card.repetition = 0;
      if (card.interval === undefined) card.interval = 0;
      if (card.ease === undefined) card.ease = 2.5;
      if (card.nextReview === undefined) card.nextReview = Date.now();
      if (card.ignored === undefined) card.ignored = false;
    }
    
    // SM-2 scheduling update: quality: 0 (Bad), 3 (OK), 5 (Good)
    function updateCard(word, quality) {
      ensureCardProperties(word);
      let card = wordData[word];
      const now = Date.now();
      if (quality < 3) {
        card.repetition = 0;
        card.interval = 1;
      } else {
        card.repetition++;
        card.interval = (card.repetition === 1) ? 1 :
                        (card.repetition === 2) ? 6 :
                        card.interval * card.ease;
        card.ease = card.ease - 0.8 + 0.28 * quality - 0.02 * quality * quality;
        if (card.ease < 1.3) card.ease = 1.3;
      }
      card.nextReview = now + card.interval * 86400000;
    }
    
    function getNextCard() {
      const now = Date.now();
      const dueCards = words.filter(w => !wordData[w].ignored && (wordData[w].nextReview <= now));
      if (dueCards.length > 0) return dueCards[Math.floor(Math.random() * dueCards.length)];
      const notIgnored = words.filter(w => !wordData[w].ignored);
      if (notIgnored.length === 0) return null;
      notIgnored.sort((a, b) => (wordData[a].nextReview || Infinity) - (wordData[b].nextReview || Infinity));
      return notIgnored[0];
    }
    
    function showCurrentCard() {
      if (!currentWord) return;
      ensureCardProperties(currentWord);
      document.getElementById("currentWord").textContent = currentWord;
      const examples = wordData[currentWord].examples;
      const randomIndex = Math.floor(Math.random() * examples.length);
      currentExampleObj = examples[randomIndex];
      document.getElementById("currentExample").textContent = currentExampleObj.text;
      document.getElementById("currentExample").style.display = "none";
    }
    
    function reviewCurrentCard(quality) {
      updateCard(currentWord, quality);
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
      else {
        document.getElementById("currentWord").textContent = "No cards available.";
        document.getElementById("currentExample").textContent = "";
      }
    }
    
    // Play video fragment using the chosen example.
    document.getElementById("playFragmentBtn").addEventListener("click", () => {
      if (!currentWord || !currentExampleObj) return;
      const videoURL = videoMapping[currentExampleObj.video];
      if (!videoURL) {
        alert("Video not available for this card.");
        return;
      }
      const drillVideo = document.getElementById("drillVideo");
      drillVideo.src = videoURL;
      drillVideo.currentTime = currentExampleObj.start;
      drillVideo.play();
      const checkInterval = setInterval(() => {
        if (drillVideo.currentTime >= currentExampleObj.end) {
          drillVideo.pause();
          clearInterval(checkInterval);
        }
      }, 100);
    });
    
    // Toggle example text visibility.
    document.getElementById("showTextBtn").addEventListener("click", () => {
      const exampleElem = document.getElementById("currentExample");
      exampleElem.style.display = (exampleElem.style.display === "none") ? "block" : "none";
    });
    
    document.getElementById("ignoreWordBtn").addEventListener("click", () => {
      if (currentWord) {
        wordData[currentWord].ignored = true;
        currentWord = getNextCard();
        if (currentWord) showCurrentCard();
        else {
          document.getElementById("currentWord").textContent = "No more cards available.";
          document.getElementById("currentExample").textContent = "";
        }
      }
    });
    
    document.querySelectorAll(".ratingBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        const quality = parseInt(btn.getAttribute("data-quality"));
        if (currentWord && wordData[currentWord]) {
          reviewCurrentCard(quality);
        }
      });
    });
    
    // Start drill on page load if available.
    window.addEventListener("load", () => {
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
    });
  </script>
</body>
</html>
