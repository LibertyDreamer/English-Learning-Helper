<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Drill Learning System</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #controls { margin-top: 20px; }
    #wordDisplay { margin-top: 20px; font-size: 1.2em; }
    #exampleDisplay { margin-top: 10px; font-style: italic; }
    #videoContainer { margin-top: 20px; }
    #ratingButtons button { margin-right: 5px; margin-top: 5px; }
  </style>
</head>
<body>
  <h1>Word Drill Learning System</h1>

  <!-- Archive load and save -->
  <div>
    <input type="file" id="fileInput" accept=".zip">
    <button id="loadButton">Load Archive</button>
    <button id="saveButton" disabled>Save Archive</button>
  </div>

  <!-- Drill display -->
  <div id="wordDisplay">
    <div><strong>Word:</strong> <span id="currentWord"></span></div>
    <div id="exampleDisplay"></div>
  </div>

  <!-- Video player -->
  <div id="videoContainer">
    <video id="videoPlayer" width="480" controls></video>
  </div>

  <!-- Rating and ignore controls -->
  <div id="controls">
    <div id="ratingButtons">
      <!-- 10 rating buttons (10%â€“100%) -->
      <button class="rating-btn" data-value="10">10%</button>
      <button class="rating-btn" data-value="20">20%</button>
      <button class="rating-btn" data-value="30">30%</button>
      <button class="rating-btn" data-value="40">40%</button>
      <button class="rating-btn" data-value="50">50%</button>
      <button class="rating-btn" data-value="60">60%</button>
      <button class="rating-btn" data-value="70">70%</button>
      <button class="rating-btn" data-value="80">80%</button>
      <button class="rating-btn" data-value="90">90%</button>
      <button class="rating-btn" data-value="100">100%</button>
    </div>
    <button id="ignoreButton" disabled>Ignore</button>
  </div>

  <!-- JSZip library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Global variables.
    let wordsData = {};    // Parsed JSON from archive.
    let videoBlobs = {};   // Mapping: video file name -> Blob URL.
    let currentWordKey = null;
    let currentExample = null;
    let zipContent = null; // Loaded ZIP content.
    let jsonFileName = null;

    // UI elements.
    const fileInput = document.getElementById('fileInput');
    const loadButton = document.getElementById('loadButton');
    const saveButton = document.getElementById('saveButton');
    const currentWordSpan = document.getElementById('currentWord');
    const exampleDisplay = document.getElementById('exampleDisplay');
    const videoPlayer = document.getElementById('videoPlayer');
    const ignoreButton = document.getElementById('ignoreButton');
    const ratingButtons = document.querySelectorAll('.rating-btn');

    // Load Archive handler.
    loadButton.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) {
        alert("Please select a zip file first.");
        return;
      }
      const arrayBuffer = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);
      zipContent = zip;
      
      // Find the JSON file (assumes one file ending with .json).
      zip.forEach((relativePath, zipEntry) => {
        if (relativePath.endsWith('.json') && !jsonFileName) {
          jsonFileName = relativePath;
        }
      });
      if (!jsonFileName) {
        alert("No JSON file found in the zip.");
        return;
      }
      
      // Parse the JSON file.
      const jsonText = await zip.file(jsonFileName).async("string");
      try {
        wordsData = JSON.parse(jsonText);
      } catch (err) {
        alert("Error parsing JSON: " + err);
        return;
      }
      
      // Load video files (assumes .mp4 files).
      const videoPromises = [];
      zip.forEach((relativePath, zipEntry) => {
        if (relativePath.endsWith('.mp4')) {
          videoPromises.push(
            zipEntry.async("blob").then(blob => {
              const url = URL.createObjectURL(blob);
              videoBlobs[relativePath] = url;
            })
          );
        }
      });
      await Promise.all(videoPromises);

      // Enable controls.
      saveButton.disabled = false;
      ignoreButton.disabled = false;
      
      // Set up rating buttons.
      ratingButtons.forEach(button => {
        button.addEventListener('click', () => {
          const newRating = parseInt(button.getAttribute('data-value'));
          // Update current example's rating (without adding new fields).
          currentExample.rating = newRating;
          updateWordSummary(currentWordKey);
          chooseNextExample();
        });
      });

      chooseNextExample();
    });

    // Choose next word and example using weighted random selection.
    function chooseNextExample() {
      const availableWords = [];
      for (const [word, details] of Object.entries(wordsData)) {
        // Only consider examples that are not ignored.
        const validExamples = details.examples.filter(ex => !ex.ignored);
        if (validExamples.length > 0) {
          let sum = 0;
          validExamples.forEach(ex => { sum += ex.rating; });
          const avg = validExamples.length ? sum / validExamples.length : 0;
          // Compute weight: lower average rating means higher chance.
          const weight = 1 + (100 - avg);
          availableWords.push({ word: word, avg: avg, weight: weight, examples: validExamples });
        }
      }
      if (availableWords.length === 0) {
        alert("No available examples to drill. All examples might be ignored.");
        return;
      }
      // Select a word weighted by (1 + (100 - average rating)).
      let totalWeight = availableWords.reduce((sum, item) => sum + item.weight, 0);
      let r = Math.random() * totalWeight;
      let selectedWordObj = availableWords[0];
      for (const item of availableWords) {
        r -= item.weight;
        if (r <= 0) {
          selectedWordObj = item;
          break;
        }
      }
      currentWordKey = selectedWordObj.word;
      
      // Select one example from the chosen word using weighted random.
      const examples = selectedWordObj.examples;
      let totalExWeight = 0;
      const exWeights = examples.map(ex => {
        const w = 1 + (100 - ex.rating);
        totalExWeight += w;
        return w;
      });
      let rEx = Math.random() * totalExWeight;
      let idx = 0;
      for (let i = 0; i < examples.length; i++) {
        rEx -= exWeights[i];
        if (rEx <= 0) {
          idx = i;
          break;
        }
      }
      currentExample = examples[idx];
      
      updateUI();
    }

    // Update UI to display the current word, example, and play the video segment automatically.
    function updateUI() {
      currentWordSpan.textContent = currentWordKey;
      exampleDisplay.textContent = currentExample.text;
      
      // Set up video based on the example's video file.
      const videoFileName = currentExample.video;
      if (videoBlobs[videoFileName]) {
        videoPlayer.src = videoBlobs[videoFileName];
      } else {
        videoPlayer.removeAttribute('src');
      }
      videoPlayer.currentTime = currentExample.start;
      // Automatically play the video segment.
      videoPlayer.play();
    }

    // Stop playback when end time is reached.
    videoPlayer.addEventListener('timeupdate', () => {
      if (currentExample && videoPlayer.currentTime >= currentExample.end) {
        videoPlayer.pause();
      }
    });

    // Ignore button: mark current example as ignored.
    ignoreButton.addEventListener('click', () => {
      currentExample.ignored = true;
      updateWordSummary(currentWordKey);
      chooseNextExample();
    });

    // Update word summary fields based on non-ignored examples.
    function updateWordSummary(wordKey) {
      const details = wordsData[wordKey];
      const validExamples = details.examples.filter(ex => !ex.ignored);
      if (validExamples.length > 0) {
        let sum = 0;
        validExamples.forEach(ex => { sum += ex.rating; });
        details.rating = sum / validExamples.length;
        details.ignored = false;
      } else {
        details.rating = 0;
        details.ignored = true;
      }
    }

    // Save Archive: update the JSON file inside a new ZIP archive and include all original files.
    saveButton.addEventListener('click', async () => {
      const newZip = new JSZip();
      // Add updated JSON file (using the same filename as loaded).
      newZip.file(jsonFileName, JSON.stringify(wordsData, null, 2));
      
      // Copy over all other files from the original archive.
      const files = Object.keys(zipContent.files);
      for (const fileName of files) {
        if (fileName === jsonFileName) continue;
        const fileObj = zipContent.file(fileName);
        if (fileObj) {
          const content = await fileObj.async("arraybuffer");
          newZip.file(fileName, content);
        }
      }
      
      // Generate and download the updated archive.
      newZip.generateAsync({ type: "blob" }).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "updated_archive.zip";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    });
  </script>
</body>
</html>
