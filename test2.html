<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Archive Drill System</title>
  <!-- Include JSZip from CDN for archive handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 10px; }
    h1, h2 { text-align: center; }
    section { border: 1px solid #ccc; padding: 10px; margin: 10px; }
    button, input { margin: 5px; }
    video { display: block; margin: 10px auto; }
  </style>
</head>
<body>
  <h1>Archive Drill System</h1>
  
  <!-- Drill Section (always visible at the top) -->
  <section id="drillSection">
    <h2>Drill</h2>
    <div id="drill-card-section">
      <!-- Word will be shown here -->
      <h3 id="currentWord"></h3>
      <!-- Initially hidden: Example text -->
      <button id="showTextBtn">Show Example</button>
      <p id="currentExample" style="display:none;"></p>
      <!-- Play the audio fragment from the video -->
      <button id="playFragmentBtn">Play Audio Fragment</button>
      <!-- Rating buttons for scheduling -->
      <div id="ratingSection">
        <button class="ratingBtn" data-quality="0">Bad</button>
        <button class="ratingBtn" data-quality="3">OK</button>
        <button class="ratingBtn" data-quality="5">Good</button>
      </div>
      <!-- Skip current word -->
      <button id="ignoreWordBtn">Ignore Word</button>
      <!-- Video element for playing the fragment -->
      <video id="drillVideo" controls width="600"></video>
    </div>
  </section>
  
  <!-- Archive Management Section -->
  <section id="archiveManagement">
    <h2>Archive Management</h2>
    <div>
      <label for="archiveFile">Load Archive (.zip):</label>
      <input type="file" id="archiveFile" accept=".zip">
    </div>
    <div>
      <button id="exportArchiveBtn">Export Archive</button>
    </div>
  </section>
  
  <!-- New Content Section: Add New Video + SRT -->
  <section id="newContentSection">
    <h2>Add New Content (Video + SRT)</h2>
    <div>
      <label for="newVideo">Video File:</label>
      <input type="file" id="newVideo" accept="video/*">
      <label for="newSRT">SRT File:</label>
      <input type="file" id="newSRT" accept=".srt">
      <button id="addNewContentBtn">Add New Content</button>
    </div>
  </section>
  
  <script>
    /**************************************************
     * Global Variables
     **************************************************/
    // wordData: key = word; value: { examples: [{ text, video, start, end }], repetition, interval, ease, nextReview, ignored }
    let wordData = {};   
    let words = [];      // Array of word keys
    let videoFiles = []; // Array of new video File objects
    let videoArchiveMapping = {}; // Mapping: video file name -> object URL
    let currentExampleObj = null; // Chosen example for the current card
    let currentWord = "";
    
    /**************************************************
     * Utility: SRT Parsing
     **************************************************/
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      let results = [];
      for (let block of blocks) {
        const lines = block.split(/\r?\n/).map(l => l.trim()).filter(l => l);
        if (lines.length < 2) continue;
        let timeLine = '';
        let textLines = [];
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          timeLine = lines[0];
          textLines = lines.slice(1);
        }
        if (!timeLine.includes('-->')) continue;
        const [startStr, endStr] = timeLine.split('-->').map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);
        const text = textLines.join(' ');
        results.push({ start: startSec, end: endSec, text: text });
      }
      return results;
    }
    
    function srtTimeToSeconds(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length < 3) return 0;
      const [hh, mm, ssMs] = parts;
      const [ss, ms] = ssMs.split(',');
      return (parseInt(hh) * 3600) + (parseInt(mm) * 60) + parseInt(ss) + (parseInt(ms) / 1000);
    }
    
    /**************************************************
     * 1) Add New Content (Video + SRT)
     **************************************************/
    document.getElementById("addNewContentBtn").addEventListener("click", () => {
      const videoInput = document.getElementById("newVideo");
      const srtInput = document.getElementById("newSRT");
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      
      // Add video file if not already loaded
      if (!videoArchiveMapping[videoFile.name]) {
        videoFiles.push(videoFile);
        videoArchiveMapping[videoFile.name] = URL.createObjectURL(videoFile);
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const srtContent = e.target.result;
        const srtBlocks = parseSRT(srtContent);
        // For each subtitle block, add new words or append new examples.
        srtBlocks.forEach(block => {
          const wordsInBlock = block.text.toLowerCase().match(/[a-zA-Z]+/g);
          if (wordsInBlock) {
            wordsInBlock.forEach(word => {
              if (!wordData[word]) {
                // Create new card with an examples array.
                wordData[word] = {
                  examples: [{
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  }],
                  repetition: 0,
                  interval: 0,
                  ease: 2.5,
                  nextReview: Date.now(),
                  ignored: false
                };
              } else {
                // Add new example if not already present.
                const exists = wordData[word].examples.some(ex => ex.text === block.text && ex.video === videoFile.name);
                if (!exists) {
                  wordData[word].examples.push({
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  });
                }
              }
            });
          }
        });
        words = Object.keys(wordData);
        alert("New content added from SRT.");
        // If drill hasn't started, start it now:
        if (!currentWord) {
          currentWord = getNextCard();
          if (currentWord) showCurrentCard();
        }
      };
      reader.readAsText(srtFile);
    });
    
    /**************************************************
     * 2) Load Archive from ZIP (JSON + Videos)
     **************************************************/
    document.getElementById("archiveFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const zip = new JSZip();
      zip.loadAsync(file).then(zipContent => {
        return zipContent.file("words.json").async("string").then(jsonStr => {
          try {
            wordData = JSON.parse(jsonStr);
            words = Object.keys(wordData);
            // Load video files from "videos" folder.
            const videoFolder = zipContent.folder("videos");
            if (videoFolder) {
              videoFolder.forEach((relPath, fileEntry) => {
                fileEntry.async("blob").then(blob => {
                  const url = URL.createObjectURL(blob);
                  videoArchiveMapping[fileEntry.name] = url;
                });
              });
            }
            alert("Archive loaded.");
            // Start drill if not already started.
            if (!currentWord) {
              currentWord = getNextCard();
              if (currentWord) showCurrentCard();
            }
          } catch (err) {
            alert("Error parsing archive: " + err);
          }
        });
      }).catch(err => {
        alert("Error loading archive: " + err);
      });
    });
    
    /**************************************************
     * 3) Export Archive (ZIP: JSON + Videos)
     **************************************************/
    document.getElementById("exportArchiveBtn").addEventListener("click", async () => {
      const zip = new JSZip();
      zip.file("words.json", JSON.stringify(wordData, null, 2));
      const videoFolder = zip.folder("videos");
      if (videoFiles.length === 0) {
        alert("No new video files loaded.");
        return;
      }
      for (const file of videoFiles) {
        videoFolder.file(file.name, file);
      }
      try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(content);
        a.download = "archive.zip";
        a.click();
      } catch(err) {
        console.error("Error exporting archive:", err);
      }
    });
    
    /**************************************************
     * 4) Drill Section: Scheduling & UI
     **************************************************/
    function ensureCardProperties(word) {
      const card = wordData[word];
      if (card.repetition === undefined) card.repetition = 0;
      if (card.interval === undefined) card.interval = 0;
      if (card.ease === undefined) card.ease = 2.5;
      if (card.nextReview === undefined) card.nextReview = Date.now();
      if (card.ignored === undefined) card.ignored = false;
    }
    
    // SM-2 scheduling update: quality: 0 (Bad), 3 (OK), 5 (Good)
    function updateCard(word, quality) {
      ensureCardProperties(word);
      let card = wordData[word];
      const now = Date.now();
      if (quality < 3) {
        card.repetition = 0;
        card.interval = 1;
      } else {
        card.repetition++;
        card.interval = (card.repetition === 1) ? 1 :
                        (card.repetition === 2) ? 6 :
                        card.interval * card.ease;
        card.ease = card.ease - 0.8 + 0.28 * quality - 0.02 * quality * quality;
        if (card.ease < 1.3) card.ease = 1.3;
      }
      card.nextReview = now + card.interval * 86400000;
    }
    
    function getNextCard() {
      const now = Date.now();
      const dueCards = words.filter(w => !wordData[w].ignored && (wordData[w].nextReview <= now));
      if (dueCards.length > 0) return dueCards[Math.floor(Math.random() * dueCards.length)];
      const notIgnored = words.filter(w => !wordData[w].ignored);
      if (notIgnored.length === 0) return null;
      notIgnored.sort((a, b) => (wordData[a].nextReview || Infinity) - (wordData[b].nextReview || Infinity));
      return notIgnored[0];
    }
    
    function showCurrentCard() {
      if (!currentWord) return;
      ensureCardProperties(currentWord);
      document.getElementById("currentWord").textContent = currentWord;
      // Choose one random example from the card.
      const examples = wordData[currentWord].examples;
      const randomIndex = Math.floor(Math.random() * examples.length);
      currentExampleObj = examples[randomIndex];
      // Initially hide the example text.
      document.getElementById("currentExample").textContent = currentExampleObj.text;
      document.getElementById("currentExample").style.display = "none";
    }
    
    let currentWordGlobal = ""; // alias for current word if needed
    function reviewCurrentCard(quality) {
      updateCard(currentWord, quality);
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
      else {
        document.getElementById("currentWord").textContent = "No cards available.";
        document.getElementById("currentExample").textContent = "";
      }
    }
    
    // Play video fragment using the chosen example.
    document.getElementById("playFragmentBtn").addEventListener("click", () => {
      if (!currentWord || !currentExampleObj) return;
      if (!currentExampleObj.video || !videoArchiveMapping[currentExampleObj.video]) {
        alert("Video not available for this card.");
        return;
      }
      const drillVideo = document.getElementById("drillVideo");
      drillVideo.src = videoArchiveMapping[currentExampleObj.video];
      drillVideo.currentTime = currentExampleObj.start;
      drillVideo.play();
      const checkInterval = setInterval(() => {
        if (drillVideo.currentTime >= currentExampleObj.end) {
          drillVideo.pause();
          clearInterval(checkInterval);
        }
      }, 100);
    });
    
    // Toggle example text visibility.
    document.getElementById("showTextBtn").addEventListener("click", () => {
      const exampleElem = document.getElementById("currentExample");
      exampleElem.style.display = (exampleElem.style.display === "none") ? "block" : "none";
    });
    
    document.getElementById("ignoreWordBtn").addEventListener("click", () => {
      if (currentWord) {
        wordData[currentWord].ignored = true;
        currentWord = getNextCard();
        if (currentWord) showCurrentCard();
        else {
          document.getElementById("currentWord").textContent = "No more cards available.";
          document.getElementById("currentExample").textContent = "";
        }
      }
    });
    
    document.querySelectorAll(".ratingBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        const quality = parseInt(btn.getAttribute("data-quality"));
        if (currentWord && wordData[currentWord]) {
          reviewCurrentCard(quality);
        }
      });
    });
    
    // If the page loads without an archive, try to start the drill (if any cards exist).
    window.addEventListener("load", () => {
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
    });
  </script>
</body>
</html>
