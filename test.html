<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>SRT Video Search from Scratch</title>
</head>
<body>
  <h1>SRT Video Search from Scratch</h1>

  <!-- 1) Choose your video file (MP4, MKV, etc. if browser supports it) -->
  <input type="file" id="videoFile" accept="video/*">
  
  <!-- 2) Choose your .srt file -->
  <input type="file" id="srtFile" accept=".srt">
  <br><br>

  <!-- 3) Enter the exact phrase as it appears in the subtitle text -->
  <input type="text" id="phraseInput" placeholder="Enter exact subtitle phrase" style="width: 300px;">
  <button id="searchBtn">Find and Play</button>

  <p id="times"></p>

  <video id="video" controls width="600"></video>

  <script>
    const video = document.getElementById('video');
    const phraseInput = document.getElementById('phraseInput');
    const timesDisplay = document.getElementById('times');

    let srtContent = '';
    let srtBlocks = [];  // Will hold parsed subtitles: { start, end, text }
    let fragmentStart = 0;
    let fragmentEnd = 0;

    // 1) When user picks a video file:
    document.getElementById('videoFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        video.src = URL.createObjectURL(file);
      }
    });

    // 2) When user picks an SRT file, parse it:
    document.getElementById('srtFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          srtContent = event.target.result;
          srtBlocks = parseSRT(srtContent);  // parse it into blocks
        };
        reader.readAsText(file);
      }
    });

    // 3) On “Find and Play,” look for the phrase in srtBlocks:
    document.getElementById('searchBtn').addEventListener('click', () => {
      const phrase = phraseInput.value.trim().toLowerCase();
      if (!phrase) {
        alert('Please type a phrase.');
        return;
      }
      if (!srtBlocks.length) {
        alert('Please load an SRT file first.');
        return;
      }

      let foundBlock = null;
      for (const block of srtBlocks) {
        // Make block text lowercase for a case-insensitive search
        const blockText = block.text.toLowerCase();
        if (blockText.includes(phrase)) {
          foundBlock = block;
          break;
        }
      }

      if (!foundBlock) {
        alert('Phrase not found in SRT.');
        return;
      }

      // Found the correct block
      fragmentStart = foundBlock.start;
      fragmentEnd = foundBlock.end + 1; // +1 second for smooth ending

      // Jump and play
      video.currentTime = fragmentStart;
      video.play();

      // Show times
      timesDisplay.textContent =
        `Fragment Start: ${fragmentStart.toFixed(2)}s, ` +
        `End: ${fragmentEnd.toFixed(2)}s (+1s)`;
    });

    // Pause automatically after we pass fragmentEnd
    video.addEventListener('timeupdate', () => {
      if (fragmentEnd > 0 && !video.paused && video.currentTime >= fragmentEnd) {
        video.pause();
      }
    });

    // --- PARSE SRT “FROM SCRATCH” ---
    // 1) Split into blocks
    // 2) Each block: 
    //    - Possibly has an index line
    //    - Has a time line “HH:MM:SS,mmm --> HH:MM:SS,mmm”
    //    - The rest is subtitle text
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      const results = [];

      for (const rawBlock of blocks) {
        // Split by lines
        // remove empty lines, trim each line
        const lines = rawBlock
          .split(/\r?\n/)
          .map(line => line.trim())
          .filter(line => line.length > 0);

        if (lines.length < 2) {
          // Not enough info in this block
          continue;
        }

        // Try to figure out which line is time and which is text
        let timeLine = '';
        let textLines = [];

        // If the first line is just a number, we assume second line is time
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          // Otherwise, first line might be the time
          timeLine = lines[0];
          textLines = lines.slice(1);
        }

        if (!timeLine.includes('-->')) {
          // This block doesn’t have a valid time line
          continue;
        }

        // Parse times
        const [startStr, endStr] = timeLine.split('-->').map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);

        // Join all text lines into one string
        const text = textLines.join(' ');

        results.push({
          start: startSec,
          end: endSec,
          text: text
        });
      }

      return results;
    }

    // Convert “HH:MM:SS,mmm” to total seconds (float)
    function srtTimeToSeconds(timeStr) {
      // e.g. "00:10:57,623" => 657.623
      const [hh, mm, ssMs] = timeStr.split(':');
      const [ss, ms] = ssMs.split(',');
      const hours = parseInt(hh, 10) || 0;
      const minutes = parseInt(mm, 10) || 0;
      const seconds = parseInt(ss, 10) || 0;
      const milliseconds = parseInt(ms, 10) || 0;
      return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
    }
  </script>
</body>
</html>
