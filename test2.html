<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Zip Archive Drill System</title>
  <!-- Include JSZip for archive handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 10px; }
    h1, h2 { text-align: center; }
    section { border: 1px solid #ccc; padding: 10px; margin: 10px; }
    button, input { margin: 5px; }
    video { display: block; margin: 10px auto; }
    #ratingSection button { margin: 2px; }
  </style>
</head>
<body>
  <h1>Zip Archive Drill System</h1>
  
  <!-- Drill Section -->
  <section id="drillSection">
    <h2>Drill</h2>
    <div id="drill-card-section">
      <h3 id="currentWord"></h3>
      <video id="drillVideo" controls width="600"></video>
      <button id="showTextBtn">Show Example</button>
      <p id="currentExample" style="display: none;"></p>
      <div id="ratingSection">
        <button class="ratingBtn" data-rating="0">0%</button>
        <button class="ratingBtn" data-rating="10">10%</button>
        <button class="ratingBtn" data-rating="20">20%</button>
        <button class="ratingBtn" data-rating="30">30%</button>
        <button class="ratingBtn" data-rating="40">40%</button>
        <button class="ratingBtn" data-rating="50">50%</button>
        <button class="ratingBtn" data-rating="60">60%</button>
        <button class="ratingBtn" data-rating="70">70%</button>
        <button class="ratingBtn" data-rating="80">80%</button>
        <button class="ratingBtn" data-rating="90">90%</button>
        <button class="ratingBtn" data-rating="100">100%</button>
      </div>
      <button id="ignoreWordBtn">Ignore Word</button>
    </div>
  </section>
  
  <!-- Archive Management Section -->
  <section id="archiveManagement">
    <h2>Archive Management</h2>
    <div>
      <label for="archiveFile">Load Archive (.zip):</label>
      <input type="file" id="archiveFile" accept=".zip">
    </div>
    <div>
      <button id="exportArchiveBtn">Export Archive</button>
    </div>
  </section>
  
  <!-- New Content Section -->
  <section id="newContentSection">
    <h2>Add New Content (Video + SRT)</h2>
    <div>
      <label for="newVideo">Video File:</label>
      <input type="file" id="newVideo" accept="video/*">
      <label for="newSRT">SRT File:</label>
      <input type="file" id="newSRT" accept=".srt">
      <button id="addNewContentBtn">Add New Content</button>
    </div>
  </section>
  
  <script>
    /**************************************************
     * Global Variables
     **************************************************/
    // wordData: { word: { examples: [{ text, video, start, end }], rating, ignored } }
    let wordData = {};   
    let words = [];      // Array of word keys
    let videoFiles = []; // Array of new video File objects (for export)
    let videoMapping = {}; // Mapping: video file name -> object URL
    let currentExampleObj = null; // Chosen example for the current card
    let currentWord = "";
    
    /**************************************************
     * Utility: SRT Parsing
     **************************************************/
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      let results = [];
      blocks.forEach(block => {
        const lines = block.split(/\r?\n/).map(l => l.trim()).filter(l => l);
        if (lines.length < 2) return;
        let timeLine = "";
        let textLines = [];
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          timeLine = lines[0];
          textLines = lines.slice(1);
        }
        if (!timeLine.includes("-->")) return;
        const [startStr, endStr] = timeLine.split("-->").map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);
        const text = textLines.join(" ");
        results.push({ start: startSec, end: endSec, text: text });
      });
      return results;
    }
    
    function srtTimeToSeconds(timeStr) {
      const parts = timeStr.split(":");
      if (parts.length < 3) return 0;
      const [hh, mm, ssMs] = parts;
      const [ss, ms] = ssMs.split(",");
      return (parseInt(hh) * 3600) + (parseInt(mm) * 60) + parseInt(ss) + (parseInt(ms) / 1000);
    }
    
    /**************************************************
     * Add New Content (Video + SRT)
     **************************************************/
    document.getElementById("addNewContentBtn").addEventListener("click", () => {
      const videoInput = document.getElementById("newVideo");
      const srtInput = document.getElementById("newSRT");
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      
      // Add video file to mapping if not already present.
      if (!videoMapping[videoFile.name]) {
        videoFiles.push(videoFile);
        videoMapping[videoFile.name] = URL.createObjectURL(videoFile);
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const srtContent = e.target.result;
        const srtBlocks = parseSRT(srtContent);
        srtBlocks.forEach(block => {
          const wordsInBlock = block.text.toLowerCase().match(/[a-zA-Z]+/g);
          if (wordsInBlock) {
            wordsInBlock.forEach(word => {
              if (!wordData[word]) {
                wordData[word] = {
                  examples: [{
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  }],
                  // Default rating is 0, so new words appear often.
                  rating: 0,
                  ignored: false
                };
              } else {
                const exists = wordData[word].examples.some(ex => ex.text === block.text && ex.video === videoFile.name);
                if (!exists) {
                  wordData[word].examples.push({
                    text: block.text,
                    video: videoFile.name,
                    start: block.start,
                    end: block.end
                  });
                }
              }
            });
          }
        });
        words = Object.keys(wordData);
        alert("New content added from SRT.");
        if (!currentWord) {
          currentWord = getNextCard();
          if (currentWord) showCurrentCard();
        }
      };
      reader.readAsText(srtFile);
    });
    
    /**************************************************
     * Load Archive from ZIP (JSON + Videos)
     **************************************************/
    document.getElementById("archiveFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const zip = new JSZip();
      zip.loadAsync(file).then(zipContent => {
        // Load JSON data
        return zipContent.file("words.json").async("string").then(jsonStr => {
          try {
            wordData = JSON.parse(jsonStr);
            words = Object.keys(wordData);
            // Load video files from "videos" folder.
            const videoFolder = zipContent.folder("videos");
            if (videoFolder) {
              videoFolder.forEach((relPath, fileEntry) => {
                fileEntry.async("blob").then(blob => {
                  const url = URL.createObjectURL(blob);
                  videoMapping[fileEntry.name] = url;
                });
              });
            }
            alert("Archive loaded.");
            if (!currentWord) {
              currentWord = getNextCard();
              if (currentWord) showCurrentCard();
            }
          } catch (err) {
            alert("Error parsing archive: " + err);
          }
        });
      }).catch(err => {
        alert("Error loading archive: " + err);
      });
    });
    
    /**************************************************
     * Export Archive to ZIP (JSON + Videos)
     **************************************************/
    document.getElementById("exportArchiveBtn").addEventListener("click", async () => {
      const zip = new JSZip();
      zip.file("words.json", JSON.stringify(wordData, null, 2));
      const videoFolder = zip.folder("videos");
      if (videoFiles.length === 0) {
        alert("No new video files loaded.");
        return;
      }
      for (const file of videoFiles) {
        videoFolder.file(file.name, file);
      }
      try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(content);
        a.download = "archive.zip";
        a.click();
      } catch(err) {
        console.error("Error exporting archive:", err);
      }
    });
    
    /**************************************************
     * Drill Section: UI and Weighted Selection
     **************************************************/
    // Remove scheduling â€“ simply update the word's rating.
    function updateCard(word, rating) {
      wordData[word].rating = rating;
    }
    
    // Select the next card using weighted random selection.
    // Words with lower ratings (e.g., 0, 10, 20) receive a higher weight.
    function getNextCard() {
      const availableWords = words.filter(w => !wordData[w].ignored);
      if (availableWords.length === 0) return null;
      let totalWeight = 0;
      const weightedWords = [];
      availableWords.forEach(word => {
        let r = wordData[word].rating;
        if (r === undefined) { r = 0; }
        // Lower ratings result in higher weight.
        const weight = 101 - r; // For example, rating 0 gives 101; rating 100 gives 1.
        totalWeight += weight;
        weightedWords.push({ word, weight });
      });
      let rand = Math.random() * totalWeight;
      for (let i = 0; i < weightedWords.length; i++) {
        rand -= weightedWords[i].weight;
        if (rand <= 0) return weightedWords[i].word;
      }
      return weightedWords[weightedWords.length - 1].word;
    }
    
    function showCurrentCard() {
      if (!currentWord) return;
      document.getElementById("currentWord").textContent = currentWord;
      const examples = wordData[currentWord].examples;
      const randomIndex = Math.floor(Math.random() * examples.length);
      currentExampleObj = examples[randomIndex];
      document.getElementById("currentExample").textContent = currentExampleObj.text;
      document.getElementById("currentExample").style.display = "none";
      
      // Auto-play video fragment when new word is shown.
      autoPlayVideoFragment();
    }
    
    function autoPlayVideoFragment() {
      if (!currentWord || !currentExampleObj) return;
      const videoURL = videoMapping[currentExampleObj.video];
      if (!videoURL) {
        alert("Video not available for this card.");
        return;
      }
      const drillVideo = document.getElementById("drillVideo");
      drillVideo.src = videoURL;
      drillVideo.currentTime = currentExampleObj.start;
      drillVideo.play();
      const checkInterval = setInterval(() => {
        if (drillVideo.currentTime >= currentExampleObj.end) {
          drillVideo.pause();
          clearInterval(checkInterval);
        }
      }, 100);
    }
    
    function reviewCurrentCard(rating) {
      updateCard(currentWord, rating);
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
      else {
        document.getElementById("currentWord").textContent = "No cards available.";
        document.getElementById("currentExample").textContent = "";
      }
    }
    
    // Toggle example text visibility.
    document.getElementById("showTextBtn").addEventListener("click", () => {
      const exampleElem = document.getElementById("currentExample");
      exampleElem.style.display = (exampleElem.style.display === "none") ? "block" : "none";
    });
    
    document.getElementById("ignoreWordBtn").addEventListener("click", () => {
      if (currentWord) {
        wordData[currentWord].ignored = true;
        currentWord = getNextCard();
        if (currentWord) showCurrentCard();
        else {
          document.getElementById("currentWord").textContent = "No more cards available.";
          document.getElementById("currentExample").textContent = "";
        }
      }
    });
    
    // Attach event listeners to percent rating buttons.
    document.querySelectorAll(".ratingBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        const rating = parseInt(btn.getAttribute("data-rating"));
        if (currentWord && wordData[currentWord]) {
          reviewCurrentCard(rating);
        }
      });
    });
    
    window.addEventListener("load", () => {
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
    });
  </script>
</body>
</html>
