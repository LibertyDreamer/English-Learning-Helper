<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Archive &amp; Drill System</title>
  <!-- Include JSZip from CDN for archive handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    /* ---------- Common Styles ---------- */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f0f2f5;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    h1, h2, h3 {
      text-align: center;
      color: #2c3e50;
    }
    section {
      margin-bottom: 40px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
    }
    input, button, label, p {
      margin: 5px;
    }
    video {
      display: block;
      margin: 10px auto;
    }
    /* ---------- Drill Card Styles ---------- */
    #drill-card-section {
      text-align: center;
    }
    #currentWord {
      font-size: 2em;
      margin-bottom: 10px;
      cursor: pointer;
    }
    #currentExample {
      font-size: 1.2em;
      margin-bottom: 15px;
    }
    #ratingSection button {
      margin: 0 5px;
    }
  </style>
</head>
<body>
  <h1>Archive &amp; Drill System</h1>
  
  <!-- ===========================
       Archive Management Section
       - Load an archive (ZIP file)
       - Add new content (video + SRT)
       - Export current archive
  ============================ -->
  <section id="archiveManagement">
    <h2>Archive Management</h2>
    <div>
      <label for="archiveFile">Load Archive (.zip):</label>
      <input type="file" id="archiveFile" accept=".zip">
    </div>
    <hr>
    <div>
      <h3>Add New Video + SRT</h3>
      <label for="newVideo">Video File:</label>
      <input type="file" id="newVideo" accept="video/*">
      <label for="newSRT">SRT File:</label>
      <input type="file" id="newSRT" accept=".srt">
      <button id="addNewContentBtn">Add New Content</button>
    </div>
    <hr>
    <div>
      <button id="exportArchiveBtn">Export Archive</button>
    </div>
  </section>
  
  <!-- ===========================
       Drill Section
  ============================ -->
  <section id="drillSection">
    <h2>Drill</h2>
    <div id="drill-card-section">
      <h3 id="currentWord"></h3>
      <p id="currentExample"></p>
      <button id="playFragmentBtn">Play Video Fragment</button>
      <div id="ratingSection">
        <button class="ratingBtn" data-quality="0">Again</button>
        <button class="ratingBtn" data-quality="3">Hard</button>
        <button class="ratingBtn" data-quality="5">Easy</button>
      </div>
      <button id="ignoreWordBtn">Ignore Word</button>
      <video id="drillVideo" controls width="600"></video>
    </div>
  </section>
  
  <!-- ===========================
       Scripts: Functionality Code
  ============================ -->
  <script>
    /**************************************************
     * Global Variables
     **************************************************/
    let wordData = {};   // { word: { example, video, start, end, repetition, interval, ease, nextReview, ignored } }
    let words = [];      // Array of word keys
    let videoFiles = []; // Array of new video File objects
    let videoArchiveMapping = {}; // Mapping: video file name -> object URL

    /**************************************************
     * Utility: SRT Parsing
     **************************************************/
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      const results = [];
      for (const rawBlock of blocks) {
        const lines = rawBlock.split(/\r?\n/).map(line => line.trim()).filter(line => line);
        if (lines.length < 2) continue;
        let timeLine = '';
        let textLines = [];
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          timeLine = lines[0];
          textLines = lines.slice(1);
        }
        if (!timeLine.includes('-->')) continue;
        const [startStr, endStr] = timeLine.split('-->').map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);
        const text = textLines.join(' ');
        results.push({ start: startSec, end: endSec, text: text });
      }
      return results;
    }

    function srtTimeToSeconds(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length < 3) return 0;
      const [hh, mm, ssMs] = parts;
      const [ss, ms] = ssMs.split(',');
      return (parseInt(hh) * 3600) + (parseInt(mm) * 60) + parseInt(ss) + (parseInt(ms) / 1000);
    }
    
    /**************************************************
     * 1) Add New Content (Video + SRT)
     **************************************************/
    document.getElementById("addNewContentBtn").addEventListener("click", () => {
      const videoInput = document.getElementById("newVideo");
      const srtInput = document.getElementById("newSRT");
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Please select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      
      // Add video file to our archive if not already added.
      if (!videoArchiveMapping[videoFile.name]) {
        videoFiles.push(videoFile);
        videoArchiveMapping[videoFile.name] = URL.createObjectURL(videoFile);
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const srtContent = e.target.result;
        const srtBlocks = parseSRT(srtContent);
        // For each subtitle block, extract words and add new cards.
        srtBlocks.forEach(block => {
          // Extract words (letters only, case-insensitive)
          const wordsInBlock = block.text.toLowerCase().match(/[a-zA-Z]+/g);
          if (wordsInBlock) {
            wordsInBlock.forEach(word => {
              if (!wordData[word]) {
                // Create new card with this word.
                wordData[word] = {
                  example: block.text,
                  video: videoFile.name,
                  start: block.start,
                  end: block.end,
                  repetition: 0,
                  interval: 0,
                  ease: 2.5,
                  nextReview: Date.now(),
                  ignored: false
                };
              }
            });
          }
        });
        // Update word list.
        words = Object.keys(wordData);
        alert("New content added from SRT.");
      };
      reader.readAsText(srtFile);
    });
    
    /**************************************************
     * 2) Load Archive from ZIP (JSON + Videos)
     **************************************************/
    document.getElementById("archiveFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const zip = new JSZip();
      zip.loadAsync(file).then((zipContent) => {
        // Load words.json from the root of the archive.
        return zipContent.file("words.json").async("string").then((jsonStr) => {
          try {
            wordData = JSON.parse(jsonStr);
            words = Object.keys(wordData);
            // Load video files from the "videos" folder.
            const videoFolder = zipContent.folder("videos");
            if (videoFolder) {
              videoFolder.forEach((relativePath, fileEntry) => {
                fileEntry.async("blob").then(blob => {
                  // Create an object URL from the blob.
                  const url = URL.createObjectURL(blob);
                  videoArchiveMapping[fileEntry.name] = url;
                  // (Optional) You might want to store these blobs in an array if needed.
                });
              });
            }
            alert("Archive loaded successfully.");
          } catch (err) {
            alert("Error parsing archive: " + err);
          }
        });
      }).catch(err => {
        alert("Error loading archive: " + err);
      });
    });
    
    /**************************************************
     * 3) Export Archive: Bundle JSON & Videos into ZIP
     **************************************************/
    document.getElementById("exportArchiveBtn").addEventListener("click", async () => {
      const zip = new JSZip();
      zip.file("words.json", JSON.stringify(wordData, null, 2));
      const videoFolder = zip.folder("videos");
      // Include new video files (if any) from our videoFiles array.
      if (videoFiles.length === 0) {
        alert("No new video files loaded.");
        return;
      }
      for (const file of videoFiles) {
        videoFolder.file(file.name, file);
      }
      try {
        const content = await zip.generateAsync({ type: "blob" });
        const archiveName = "archive.zip";
        const a = document.createElement("a");
        a.href = URL.createObjectURL(content);
        a.download = archiveName;
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch (err) {
        console.error("Error generating archive:", err);
      }
    });
    
    /**************************************************
     * 4) Drill Section: Scheduling & UI
     **************************************************/
    function ensureCardProperties(word) {
      const card = wordData[word];
      if (card.repetition === undefined) card.repetition = 0;
      if (card.interval === undefined) card.interval = 0;
      if (card.ease === undefined) card.ease = 2.5;
      if (card.nextReview === undefined) card.nextReview = Date.now();
      if (card.ignored === undefined) card.ignored = false;
    }
    
    // SM-2 scheduling update (quality: 0 = Again, 3 = Hard, 5 = Easy)
    function updateCard(word, quality) {
      ensureCardProperties(word);
      let card = wordData[word];
      const now = Date.now();
      if (quality < 3) {
        card.repetition = 0;
        card.interval = 1;
      } else {
        card.repetition++;
        card.interval = (card.repetition === 1) ? 1 :
                        (card.repetition === 2) ? 6 :
                        card.interval * card.ease;
        card.ease = card.ease - 0.8 + 0.28 * quality - 0.02 * quality * quality;
        if (card.ease < 1.3) card.ease = 1.3;
      }
      card.nextReview = now + card.interval * 86400000;
    }
    
    function getNextCard() {
      const now = Date.now();
      const dueCards = words.filter(w => !wordData[w].ignored && (wordData[w].nextReview || 0) <= now);
      if (dueCards.length > 0) return dueCards[Math.floor(Math.random() * dueCards.length)];
      const notIgnored = words.filter(w => !wordData[w].ignored);
      if (notIgnored.length === 0) return null;
      notIgnored.sort((a, b) => (wordData[a].nextReview || Infinity) - (wordData[b].nextReview || Infinity));
      return notIgnored[0];
    }
    
    function showCurrentCard() {
      if (!currentWord) return;
      ensureCardProperties(currentWord);
      document.getElementById("currentWord").textContent = currentWord;
      document.getElementById("currentExample").textContent = wordData[currentWord].example;
    }
    
    let currentWord = "";
    function reviewCurrentCard(quality) {
      updateCard(currentWord, quality);
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
      else {
        document.getElementById("currentWord").textContent = "No cards available.";
        document.getElementById("currentExample").textContent = "";
      }
    }
    
    // Play video fragment for the current card.
    document.getElementById("playFragmentBtn").addEventListener("click", () => {
      if (!currentWord) return;
      const card = wordData[currentWord];
      if (!card.video || !videoArchiveMapping[card.video]) {
        alert("Video file not available for this card.");
        return;
      }
      const drillVideo = document.getElementById("drillVideo");
      drillVideo.src = videoArchiveMapping[card.video];
      drillVideo.currentTime = card.start;
      drillVideo.play();
      // Stop playback after reaching the card's end time.
      let checkInterval = setInterval(() => {
        if (drillVideo.currentTime >= card.end) {
          drillVideo.pause();
          clearInterval(checkInterval);
        }
      }, 100);
    });
    
    // Clicking on the current word copies the word and example to clipboard, then opens ChatGPT.
    document.getElementById("currentWord").addEventListener("click", () => {
      if (!currentWord) return;
      const card = wordData[currentWord];
      const textToCopy = currentWord + "\n" + card.example;
      navigator.clipboard.writeText(textToCopy).then(() => {
        window.open("https://chat.openai.com/", "_blank");
      }).catch(err => {
        console.error("Failed to copy text:", err);
      });
    });
    
    document.getElementById("ignoreWordBtn").addEventListener("click", () => {
      if (currentWord) {
        wordData[currentWord].ignored = true;
        currentWord = getNextCard();
        if (currentWord) showCurrentCard();
        else {
          document.getElementById("currentWord").textContent = "No more cards available.";
          document.getElementById("currentExample").textContent = "";
        }
      }
    });
    
    document.querySelectorAll(".ratingBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        const quality = parseInt(btn.getAttribute("data-quality"));
        if (currentWord && wordData[currentWord]) {
          reviewCurrentCard(quality);
        }
      });
    });
    
    // Initialize drill on window load.
    window.addEventListener("load", () => {
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
    });
  </script>
</body>
</html>
