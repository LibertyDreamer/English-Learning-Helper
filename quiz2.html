<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title></title>
  <style>
    /* Old PC / Terminal styling */
    body {
      background-color: black;
      color: #00ff00; /* bright green text */
      font-family: monospace;
      margin: 0;
      padding: 0;
    }
    #container {
      width: 90%;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      border: 2px solid #00ff00;
    }
    h1, h2 {
      color: #00ff00;
      margin: 0 0 10px;
    }
    #intro, #game-area {
      margin-bottom: 20px;
    }
    /* Buttons and Inputs */
    .green-btn {
      background-color: black;
      color: #00ff00;
      font-family: monospace;
      border: 1px solid #00ff00;
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
    }
    .green-btn:hover {
      background-color: #003300;
    }
    input[type="text"] {
      background-color: black;
      color: #00ff00;
      border: 1px solid #00ff00;
      font-family: monospace;
      padding: 5px;
      margin: 5px 0;
      width: 400px;
    }
    /* Text display area */
    #story {
      margin-top: 20px;
      line-height: 1.4;
      border: 1px dashed #00ff00;
      padding: 10px;
      min-height: 150px;
    }
    /* Make each token clickable, no highlights or question marks */
    .word {
      cursor: pointer;
      text-decoration: none;
      color: #00ff00;
    }
    .word:hover {
      background-color: #003300;
    }
    p {
      margin: 0 0 1em 0; /* spacing between paragraphs */
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Space adventure</h1>

    <div id="intro">
      <p>
        Enter your Azure API key.
      </p>
      <input id="pat" placeholder="Enter your Azure OpenAI PAT" />
      <br>
      <button class="green-btn" onclick="startGame()">Start Game</button>
    </div>

    <div id="game-area" style="display:none;">
      <div id="story"></div>
      <div style="margin-top:10px;">
        <input type="text" id="player-input" placeholder="Type a sentence with 'somebody' or 'anybody'">
        <button class="green-btn" onclick="sendPlayerInput()">Send</button>
      </div>
    </div>
  </div>

  <script>
    /********************************************************
     * 1) CONFIG & GLOBALS
     ********************************************************/
    // Azure OpenAI endpoint (replace if needed)
    const endpoint = 'https://models.inference.ai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-02-15-preview';
    // Model name header required by Azure
    const modelHeader = { 'x-ms-model-mesh-model-name': 'gpt-4o' };

    // We'll store the conversation with the AI in this array of messages.
    // This is the "game" memory so the AI remembers the story in one session.
    let messages = [];
    let pat = ''; // We'll store the user's PAT

    /********************************************************
     * 2) START GAME
     ********************************************************/
    function startGame() {
      pat = document.getElementById('pat').value.trim();
      if (!pat) {
        alert("Please enter your Azure OpenAI PAT!");
        return;
      }

      document.getElementById('game-area').style.display = 'block';

      // The system prompt with your updated instructions:
      messages = [
        {
          role: 'system',
          content: `You are a text-based game engine for learning the difference between "somebody" and "anybody" in English. 
- The setting is a comedic and extremely dark space adventure.
- The user must type a sentence containing the learning words.
- Every time then user make right or wrong decision between learning words make it obvious throughout the story!
Somehow add explanation why it was grammatically correct or not, but don't explain straight, 
and include it inside story like it's a part of that story and not grammar lesson
- I want this game feels like real game!
- Vocabulary for A0 - A2. Ultraviolence is included!
- If they use the correct usage in context, continue the story in a fun, light-hearted way.
- If they use the wrong usage, continue the story in a dark, creepy way, possibly leading to their dead.
- Always end your response with a prompt asking them to type another sentence with learning words unless the game is over.
- Keep track of the storyline in one session.`
        },
        {
          role: 'user',
          content: `Hello! Start the game now.`
        }
      ];

      // Get the first AI response (story introduction)
      callOpenAI(messages)
        .then(responseText => {
          updateStory(responseText);
        })
        .catch(err => {
          document.getElementById('story').textContent = "Error: " + err;
        });
    }

    /********************************************************
     * 3) PLAYER INPUT
     ********************************************************/
    function sendPlayerInput() {
      const inputField = document.getElementById('player-input');
      const userSentence = inputField.value.trim();
      if (!userSentence) {
        alert("Please type a sentence containing 'somebody' or 'anybody'.");
        return;
      }

      // Add the user's sentence as a new user message
      messages.push({
        role: 'user',
        content: userSentence
      });

      inputField.value = ''; // clear the input

      // Call the AI for the next part of the story
      callOpenAI(messages)
        .then(responseText => {
          updateStory(responseText);
        })
        .catch(err => {
          document.getElementById('story').textContent = "Error: " + err;
        });
    }

    /********************************************************
     * 4) CLICK-TO-DEFINE (ANY WORD, WITH CONTEXT)
     ********************************************************/
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('word')) {
        const clickedWord = e.target.getAttribute('data-word');
        // The entire paragraph is stored in data-context
        const paragraphContext = e.target.getAttribute('data-context');
        defineWord(clickedWord, paragraphContext);
      }
    });

    async function defineWord(word, context) {
      try {
        const definitionConversation = [
          {
            role: 'system',
            content: `You are a dictionary. Explain meaning of this word or words inside this exact context. It should be A0-A1 explanation. Add IPA.`
          },
          {
            role: 'user',
            content: `Word: "${word}" Context: "${context}"`
          }
        ];
        const defText = await callOpenAI(definitionConversation);
        alert(`${defText}`);
      } catch (err) {
        alert("Error getting definition: " + err);
      }
    }

    /********************************************************
     * 5) CALL AZURE OPENAI
     ********************************************************/
    async function callOpenAI(convArray) {
      const bodyData = {
        messages: convArray,
        temperature: 1,
        max_tokens: 1024,
        top_p: 1
      };

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + pat,
          ...modelHeader
        },
        body: JSON.stringify(bodyData)
      });

      const data = await response.json();

      if (data.error) {
        throw new Error(JSON.stringify(data.error));
      }
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No response from AI");
      }

      const aiMessage = data.choices[0].message.content;
      // Add AI's response to the main conversation if it's the main "messages"
      if (convArray === messages) {
        messages.push({
          role: 'assistant',
          content: aiMessage
        });
      }
      return aiMessage;
    }

    /********************************************************
     * 6) SHOWING THE STORY WITH CLICKABLE WORDS & PARAGRAPHS
     ********************************************************/
    function updateStory(aiText) {
      // 1) Split text into paragraphs based on double newlines
      // 2) For each paragraph, wrap words in clickable <span> elements
      // 3) Join everything into final HTML
      const paragraphsHTML = parseTextToParagraphs(aiText);
      const storyDiv = document.getElementById('story');
      storyDiv.innerHTML = paragraphsHTML;
    }

    // Splits text into paragraphs (by double newline), then wraps each paragraphâ€™s words
    function parseTextToParagraphs(text) {
      // Split on blank lines (double newlines)
      const paragraphs = text
        .trim()
        .split(/\n\s*\n/); // match double newline or blank lines

      // Convert each paragraph into HTML with clickable words
      const htmlParagraphs = paragraphs.map(par => {
        const wrapped = parseAndWrapWords(par);
        return `<p>${wrapped}</p>`;
      });

      return htmlParagraphs.join("\n");
    }

    // Replaces each token with a clickable .word <span>,
    // storing the entire paragraph text in data-context
    function parseAndWrapWords(paragraphText) {
      const tokens = paragraphText.split(/\s+/);
      // We'll store the entire paragraph as context
      const safeContext = escapeHtml(paragraphText);

      const wrappedTokens = tokens.map(token => {
        // We'll remove trailing punctuation from the data-word
        const cleanToken = token.replace(/[.,!?;:]+$/, '');
        return `<span class="word" data-word="${cleanToken}" data-context="${safeContext}">${token}</span>`;
      });
      return wrappedTokens.join(" ");
    }

    // Basic HTML escaping for storing paragraph text in data-context
    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
  </script>
</body>
</html>
