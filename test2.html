<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Simple Archive & Drill</title>
  <!-- JSZip for archive handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 10px; }
    h1, h2 { text-align: center; }
    section { border: 1px solid #ccc; padding: 10px; margin: 10px; }
    button, input { margin: 5px; }
    video { display: block; margin: 10px auto; }
  </style>
</head>
<body>
  <h1>Simple Archive & Drill</h1>
  
  <!-- Archive Management Section -->
  <section id="archiveManagement">
    <h2>Archive Management</h2>
    <div>
      <label for="archiveFile">Load Archive (.zip):</label>
      <input type="file" id="archiveFile" accept=".zip">
    </div>
    <hr>
    <div>
      <h3>Add New Video + SRT</h3>
      <label for="newVideo">Video File:</label>
      <input type="file" id="newVideo" accept="video/*">
      <label for="newSRT">SRT File:</label>
      <input type="file" id="newSRT" accept=".srt">
      <button id="addNewContentBtn">Add New Content</button>
    </div>
    <hr>
    <div>
      <button id="exportArchiveBtn">Export Archive</button>
    </div>
  </section>
  
  <!-- Drill Section -->
  <section id="drillSection">
    <h2>Drill</h2>
    <div id="drill-card-section">
      <h3 id="currentWord"></h3>
      <p id="currentExample"></p>
      <button id="playFragmentBtn">Play Video Fragment</button>
      <div id="ratingSection">
        <button class="ratingBtn" data-quality="0">Again</button>
        <button class="ratingBtn" data-quality="3">Hard</button>
        <button class="ratingBtn" data-quality="5">Easy</button>
      </div>
      <button id="ignoreWordBtn">Ignore Word</button>
      <video id="drillVideo" controls width="600"></video>
    </div>
  </section>
  
  <script>
    // Global variables
    let wordData = {};   // { word: { example, video, start, end, repetition, interval, ease, nextReview, ignored } }
    let words = [];      // Array of word keys
    let videoFiles = []; // Array of new video File objects
    let videoArchiveMapping = {}; // Mapping: video file name -> object URL

    // --- Utility Functions ---
    function parseSRT(srtString) {
      const blocks = srtString.split(/\r?\n\r?\n/);
      let results = [];
      for (let block of blocks) {
        const lines = block.split(/\r?\n/).map(l => l.trim()).filter(l => l);
        if (lines.length < 2) continue;
        let timeLine = '';
        let textLines = [];
        if (/^\d+$/.test(lines[0])) {
          timeLine = lines[1];
          textLines = lines.slice(2);
        } else {
          timeLine = lines[0];
          textLines = lines.slice(1);
        }
        if (!timeLine.includes('-->')) continue;
        const [startStr, endStr] = timeLine.split('-->').map(s => s.trim());
        const startSec = srtTimeToSeconds(startStr);
        const endSec = srtTimeToSeconds(endStr);
        const text = textLines.join(' ');
        results.push({ start: startSec, end: endSec, text: text });
      }
      return results;
    }

    function srtTimeToSeconds(timeStr) {
      const parts = timeStr.split(':');
      if (parts.length < 3) return 0;
      const [hh, mm, ssMs] = parts;
      const [ss, ms] = ssMs.split(',');
      return (parseInt(hh) * 3600) + (parseInt(mm) * 60) + parseInt(ss) + (parseInt(ms) / 1000);
    }
    
    // --- Add New Content (Video + SRT) ---
    document.getElementById("addNewContentBtn").addEventListener("click", () => {
      const videoInput = document.getElementById("newVideo");
      const srtInput = document.getElementById("newSRT");
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      
      // Add video file if not already loaded
      if (!videoArchiveMapping[videoFile.name]) {
        videoFiles.push(videoFile);
        videoArchiveMapping[videoFile.name] = URL.createObjectURL(videoFile);
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const srtContent = e.target.result;
        const srtBlocks = parseSRT(srtContent);
        // For each subtitle block, add each new word as a card if not already present.
        srtBlocks.forEach(block => {
          const wordsInBlock = block.text.toLowerCase().match(/[a-zA-Z]+/g);
          if (wordsInBlock) {
            wordsInBlock.forEach(word => {
              if (!wordData[word]) {
                wordData[word] = {
                  example: block.text,
                  video: videoFile.name,
                  start: block.start,
                  end: block.end,
                  repetition: 0,
                  interval: 0,
                  ease: 2.5,
                  nextReview: Date.now(),
                  ignored: false
                };
              }
            });
          }
        });
        words = Object.keys(wordData);
        alert("New content added.");
      };
      reader.readAsText(srtFile);
    });
    
    // --- Load Archive (ZIP file) ---
    document.getElementById("archiveFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const zip = new JSZip();
      zip.loadAsync(file).then(zipContent => {
        return zipContent.file("words.json").async("string").then(jsonStr => {
          try {
            wordData = JSON.parse(jsonStr);
            words = Object.keys(wordData);
            // Load video files from "videos" folder.
            const videoFolder = zipContent.folder("videos");
            if (videoFolder) {
              videoFolder.forEach((relPath, fileEntry) => {
                fileEntry.async("blob").then(blob => {
                  const url = URL.createObjectURL(blob);
                  videoArchiveMapping[fileEntry.name] = url;
                });
              });
            }
            alert("Archive loaded.");
          } catch (err) {
            alert("Error parsing archive: " + err);
          }
        });
      }).catch(err => {
        alert("Error loading archive: " + err);
      });
    });
    
    // --- Export Archive (ZIP file) ---
    document.getElementById("exportArchiveBtn").addEventListener("click", async () => {
      const zip = new JSZip();
      zip.file("words.json", JSON.stringify(wordData, null, 2));
      const videoFolder = zip.folder("videos");
      if (videoFiles.length === 0) {
        alert("No new video files loaded.");
        return;
      }
      for (const file of videoFiles) {
        videoFolder.file(file.name, file);
      }
      try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(content);
        a.download = "archive.zip";
        a.click();
      } catch(err) {
        console.error("Error exporting archive:", err);
      }
    });
    
    // --- Drill Section Scheduling & UI ---
    function ensureCardProperties(word) {
      const card = wordData[word];
      if (card.repetition === undefined) card.repetition = 0;
      if (card.interval === undefined) card.interval = 0;
      if (card.ease === undefined) card.ease = 2.5;
      if (card.nextReview === undefined) card.nextReview = Date.now();
      if (card.ignored === undefined) card.ignored = false;
    }
    
    // SM-2 scheduling update: quality 0 = Again, 3 = Hard, 5 = Easy.
    function updateCard(word, quality) {
      ensureCardProperties(word);
      let card = wordData[word];
      const now = Date.now();
      if (quality < 3) {
        card.repetition = 0;
        card.interval = 1;
      } else {
        card.repetition++;
        card.interval = (card.repetition === 1) ? 1 :
                        (card.repetition === 2) ? 6 :
                        card.interval * card.ease;
        card.ease = card.ease - 0.8 + 0.28 * quality - 0.02 * quality * quality;
        if (card.ease < 1.3) card.ease = 1.3;
      }
      card.nextReview = now + card.interval * 86400000;
    }
    
    function getNextCard() {
      const now = Date.now();
      const dueCards = words.filter(w => !wordData[w].ignored && (wordData[w].nextReview <= now));
      if (dueCards.length > 0) return dueCards[Math.floor(Math.random()*dueCards.length)];
      const notIgnored = words.filter(w => !wordData[w].ignored);
      if (notIgnored.length === 0) return null;
      notIgnored.sort((a,b) => (wordData[a].nextReview || Infinity) - (wordData[b].nextReview || Infinity));
      return notIgnored[0];
    }
    
    function showCurrentCard() {
      if (!currentWord) return;
      ensureCardProperties(currentWord);
      document.getElementById("currentWord").textContent = currentWord;
      document.getElementById("currentExample").textContent = wordData[currentWord].example;
    }
    
    let currentWord = "";
    function reviewCurrentCard(quality) {
      updateCard(currentWord, quality);
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
      else {
        document.getElementById("currentWord").textContent = "No cards available.";
        document.getElementById("currentExample").textContent = "";
      }
    }
    
    // Play video fragment for the current card.
    document.getElementById("playFragmentBtn").addEventListener("click", () => {
      if (!currentWord) return;
      const card = wordData[currentWord];
      if (!card.video || !videoArchiveMapping[card.video]) {
        alert("Video not available for this card.");
        return;
      }
      const drillVideo = document.getElementById("drillVideo");
      drillVideo.src = videoArchiveMapping[card.video];
      drillVideo.currentTime = card.start;
      drillVideo.play();
      const checkInterval = setInterval(() => {
        if (drillVideo.currentTime >= card.end) {
          drillVideo.pause();
          clearInterval(checkInterval);
        }
      }, 100);
    });
    
    document.getElementById("ignoreWordBtn").addEventListener("click", () => {
      if (currentWord) {
        wordData[currentWord].ignored = true;
        currentWord = getNextCard();
        if (currentWord) showCurrentCard();
        else {
          document.getElementById("currentWord").textContent = "No more cards available.";
          document.getElementById("currentExample").textContent = "";
        }
      }
    });
    
    document.querySelectorAll(".ratingBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        const quality = parseInt(btn.getAttribute("data-quality"));
        if (currentWord && wordData[currentWord]) {
          reviewCurrentCard(quality);
        }
      });
    });
    
    window.addEventListener("load", () => {
      currentWord = getNextCard();
      if (currentWord) showCurrentCard();
    });
  </script>
</body>
</html>
