<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Video & SRT Archive Manager</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    section { margin-bottom: 30px; }
    h2 { margin-bottom: 10px; }
    input, button { margin: 5px 0; }
  </style>
</head>
<body>
  <h1>Video & SRT Archive Manager</h1>

  <!-- Archive Section: One button to either load an existing archive or create a new one -->
  <section id="archive-management">
    <h2>Open Archive</h2>
    <p>Choose an archive ZIP file (or leave empty to create a new archive):</p>
    <input type="file" id="archiveInput" accept=".zip">
    <button id="openArchiveButton">Open Archive</button>
  </section>

  <!-- Add New Pair Section -->
  <section id="add-pair">
    <h2>Add New Video and SRT Pair</h2>
    <input type="file" id="videoInput" accept="video/*">
    <input type="file" id="srtInput" accept=".srt">
    <button id="addPairButton">Add New Pair</button>
  </section>

  <!-- JSON Editor Section -->
  <section id="json-editor-section">
    <h2>Edit JSON Archive</h2>
    <div id="jsonEditor" style="height: 300px; width: 100%; border: 1px solid #ccc;"></div>
  </section>

  <!-- Download Archive Section -->
  <section id="download-section">
    <h2>Generate & Download Archive</h2>
    <button id="generateArchiveButton">Generate Archive</button>
  </section>

  <!-- Include external libraries: JSZip and Ace Editor -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js"></script>
  <script>
    // Global variables
    let archive = {};          // Archive JSON object: { word: { examples: [...], rating: 0, ignored: false } }
    let storedFiles = {};      // Stored files: { filename: Blob } for video/SRT files

    // Initialize Ace Editor for JSON editing
    let editor = ace.edit("jsonEditor");
    editor.session.setMode("ace/mode/json");
    editor.setTheme("ace/theme/github");
    editor.setValue(JSON.stringify(archive, null, 2), -1);

    // Update the Ace Editor with the current archive JSON.
    function updateEditor() {
      editor.setValue(JSON.stringify(archive, null, 2), -1);
    }

    // Auto-save JSON changes after 500ms of inactivity.
    let autoSaveTimeout;
    editor.session.on('change', function() {
      clearTimeout(autoSaveTimeout);
      autoSaveTimeout = setTimeout(() => {
        try {
          const newJson = JSON.parse(editor.getValue());
          archive = newJson;
          console.log("JSON auto-saved.");
        } catch(e) {
          console.error("Invalid JSON:", e.message);
        }
      }, 500);
    });

    // Checks if a given subtitle example already exists in an array.
    function exampleExists(exampleArr, newExample) {
      return exampleArr.some(existing =>
        existing.text === newExample.text &&
        existing.video === newExample.video &&
        existing.start === newExample.start &&
        existing.end === newExample.end
      );
    }

    // Parse the SRT file into subtitle blocks—ignoring the index and time lines.
    function parseSRT(srtText) {
      const blocks = srtText.trim().split(/\r?\n\r?\n/);
      let subtitles = [];
      blocks.forEach(block => {
        const lines = block.split(/\r?\n/);
        if (lines.length < 3) return; // Must have at least index, time, and text
        const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
        if (!timeMatch) return;
        const start = toSeconds(timeMatch[1]);
        const end = toSeconds(timeMatch[2]);
        const text = lines.slice(2).join(' ').trim();
        subtitles.push({ start, end, text });
      });
      return subtitles;
    }

    // Convert SRT time (hh:mm:ss,ms) to seconds.
    function toSeconds(timeStr) {
      const parts = timeStr.split(/[:,]/);
      return (+parts[0]) * 3600 + (+parts[1]) * 60 + (+parts[2]) + (+parts[3]) / 1000;
    }

    // Update the archive JSON using the subtitle data and video file name.
    function updateArchiveWithSubtitles(subtitles, videoFileName) {
      subtitles.forEach(sub => {
        const exampleObj = {
          text: sub.text,
          video: videoFileName,
          start: sub.start,
          end: sub.end
        };
        const words = sub.text.toLowerCase().match(/\b\w+\b/g);
        if (words) {
          const uniqueWords = Array.from(new Set(words));
          uniqueWords.forEach(word => {
            if (!archive[word]) {
              archive[word] = { examples: [], rating: 0, ignored: false };
            }
            if (!exampleExists(archive[word].examples, exampleObj)) {
              archive[word].examples.push(exampleObj);
            }
          });
        }
      });
    }

    // Open Archive button: if a file is chosen, load it; otherwise, create a new archive.
    document.getElementById('openArchiveButton').addEventListener('click', () => {
      const fileInput = document.getElementById('archiveInput');
      if (fileInput.files.length > 0) {
        const zipFile = fileInput.files[0];
        JSZip.loadAsync(zipFile).then(zip => {
          let promises = [];
          storedFiles = {};
          archive = {};
          Object.keys(zip.files).forEach(filename => {
            const file = zip.files[filename];
            if (!file.dir) {
              if (filename === "archive.json") {
                promises.push(
                  file.async("string").then(content => {
                    try {
                      archive = JSON.parse(content);
                    } catch(e) {
                      console.error("Error parsing archive.json:", e);
                    }
                  })
                );
              } else {
                promises.push(
                  file.async("blob").then(blob => {
                    storedFiles[filename] = blob;
                  })
                );
              }
            }
          });
          Promise.all(promises).then(() => {
            updateEditor();
            alert("Archive loaded successfully.");
          });
        });
      } else {
        // No file chosen—create a new archive.
        archive = {};
        storedFiles = {};
        updateEditor();
        alert("New archive created.");
      }
    });

    // Add New Pair button: processes the selected video and SRT files.
    document.getElementById('addPairButton').addEventListener('click', () => {
      const videoInput = document.getElementById('videoInput');
      const srtInput = document.getElementById('srtInput');
      if (videoInput.files.length === 0 || srtInput.files.length === 0) {
        alert("Please select both a video and an SRT file.");
        return;
      }
      const videoFile = videoInput.files[0];
      const srtFile = srtInput.files[0];
      const reader = new FileReader();
      reader.onload = function(e) {
        const srtText = e.target.result;
        const subtitles = parseSRT(srtText);
        updateArchiveWithSubtitles(subtitles, videoFile.name);
        storedFiles[videoFile.name] = videoFile;
        storedFiles[srtFile.name] = srtFile;
        updateEditor();
        alert("New pair added to the archive.");
      };
      reader.readAsText(srtFile);
    });

    // Generate and automatically trigger the download of the ZIP archive.
    function generateZipArchive() {
      const zip = new JSZip();
      Object.keys(storedFiles).forEach(filename => {
        zip.file(filename, storedFiles[filename]);
      });
      zip.file("archive.json", JSON.stringify(archive, null, 2));
      zip.generateAsync({ type: "blob" }).then(content => {
        const a = document.createElement('a');
        const url = URL.createObjectURL(content);
        a.href = url;
        a.download = "archive.zip";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
      });
    }
    document.getElementById('generateArchiveButton').addEventListener('click', generateZipArchive);
  </script>
</body>
</html>
